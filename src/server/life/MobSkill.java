/* This file is part of the OdinMS Maple Story Server Copyright (C) 2008 ~ 2010 Patrick Huy <patrick.huy@frz.cc>  Matthias Butz <matze@odinms.de> Jan Christian Meyer <vimes@odinms.de> This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License version 3 as published by the Free Software Foundation. You may not use, modify or distribute this program under any other version of the GNU Affero General Public License. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more details.나 You should have received a copy of the GNU Affero General Public Liceㄴnse along with this program.  If not, see <http://www.gnu.org/licenses/>. */package server.life;import client.MapleBuffStat;import client.MapleCharacter;import client.status.MonsterStatus;import client.status.MonsterStatusEffect;import constants.GameConstants;import server.Obstacle;import server.Randomizer;import server.Timer.MapTimer;import server.Timer.MobTimer;import server.field.boss.demian.MapleDelayedAttack;import server.field.boss.demian.MapleFlyingSword;import server.field.boss.lotus.MapleEnergySphere;import server.field.boss.lucid.Butterfly;import server.field.boss.lucid.FairyDust;import server.field.boss.lucid.FieldLucid;import server.field.boss.will.SpiderWeb;import server.field.boss.will.WillPoison;import server.maps.*;import server.maps.MapleNodes.Environment;import tools.Pair;import tools.Triple;import tools.packet.CField;import tools.packet.CField.EffectPacket;import tools.packet.CWvsContext;import tools.packet.CWvsContext.BuffPacket;import tools.packet.MobPacket;import tools.packet.MobPacket.BossLucid;import tools.packet.MobPacket.BossWill;import java.awt.*;import java.util.List;import java.util.*;public class MobSkill {    private int skillId, skillLevel, mpCon, spawnEffect, hp, x, y, action;    private long duration, interval, skillForbid;    private float prop;    //    private short effect_delay;    private short limit;    private List<Integer> toSummon = new ArrayList<Integer>();    private Point lt, rb;    private boolean summonOnce, onlyFsm, onlyOtherSkill, isMobGroup;    private int skillAfter, otherSkillID, otherSkillLev, afterAttack, afterAttackCount, afterDead;    public MobSkill(int skillId, int level) {        this.skillId = skillId;        this.skillLevel = level;    }    public void setOnce(boolean o) {        this.summonOnce = o;    }    public boolean onlyOnce() {        return summonOnce;    }    public void setMpCon(int mpCon) {        this.mpCon = mpCon;    }    public void addSummons(List<Integer> toSummon) {        this.toSummon = toSummon;    }    /*   public void setEffectDelay(short effect_delay) {     this.effect_delay = effect_delay;     }*/    public void setSpawnEffect(int spawnEffect) {        this.spawnEffect = spawnEffect;    }    public void setHp(int hp) {        this.hp = hp;    }    public void setX(int x) {        this.x = x;    }    public void setY(int y) {        this.y = y;    }    public void setProp(float prop) {        this.prop = prop;    }    public void setLtRb(Point lt, Point rb) {        this.lt = lt;        this.rb = rb;    }    public void setLimit(short limit) {        this.limit = limit;    }    public boolean checkCurrentBuff(MapleCharacter player, MapleMonster monster) {        boolean stop = false;        switch (skillId) {            case 100:            case 110:            case 150:                stop = monster.isBuffed(MonsterStatus.MS_Pad);                break;            case 101:            case 111:            case 151:                stop = monster.isBuffed(MonsterStatus.MS_Mad);                break;            case 102:            case 112:            case 152:                stop = monster.isBuffed(MonsterStatus.MS_Pdr);                break;            case 103:            case 113:            case 153:                stop = monster.isBuffed(MonsterStatus.MS_Mdr);                break;            //154-157, don't stop it            case 140:            case 141:            case 142:            case 143:            case 144:            case 145:                stop = monster.isBuffed(MonsterStatus.MS_Hardskin) || monster.isBuffed(MonsterStatus.MS_PowerImmune) || monster.isBuffed(MonsterStatus.MS_MImmune) || monster.isBuffed(MonsterStatus.MS_PImmune);                break;            case 200:            case 201:                for (Integer mobId : getSummons()) {                    if (player.getMap().countMonsterById(mobId) >= limit) {                        return true;                    }                }                break;        }        stop |= monster.isBuffed(MonsterStatus.MS_MagicCrash);        return stop;    }    public void applyEffect(final MapleCharacter player, final MapleMonster monster, boolean skill, boolean isFacingLeft) {        try {            Map<MapleBuffStat, Pair<Integer, Integer>> diseases = new EnumMap<>(MapleBuffStat.class);            Map<MonsterStatus, MonsterStatusEffect> stats = new EnumMap<MonsterStatus, MonsterStatusEffect>(MonsterStatus.class);            switch (skillId) {                case 100: // 공증                    stats.put(MonsterStatus.MS_Pad, new MonsterStatusEffect(skillId, (int) duration, x));                    break;                case 101: // 마증                    stats.put(MonsterStatus.MS_Mad, new MonsterStatusEffect(skillId, (int) duration, x));                    break;                case 102: // 물방증                    stats.put(MonsterStatus.MS_Pdr, new MonsterStatusEffect(skillId, (int) duration, x));                    break;                case 103: // 마방증                    stats.put(MonsterStatus.MS_Mdr, new MonsterStatusEffect(skillId, (int) duration, x));                    break;                case 105: // 힐                    if (lt != null && rb != null && skill && monster != null) {                        List<MapleMapObject> objects = getObjectsInRange(monster, MapleMapObjectType.MONSTER);                        for (MapleMapObject mons : objects) {                            if (mons.getObjectId() != monster.getObjectId()) {                                player.getMap().killMonster((MapleMonster) mons, player, true, false, (byte) 1, 0);                                monster.heal(getX(), getY(), true);                                break;                            }                        }                    } else if (monster != null) {                        monster.heal(getX(), getY(), true);                    }                    break;                case 110: // 공증                    stats.put(MonsterStatus.MS_Pad, new MonsterStatusEffect(skillId, (int) duration, x));                    break;                case 111: // 마증                    stats.put(MonsterStatus.MS_Mad, new MonsterStatusEffect(skillId, (int) duration, x));                    break;                case 112: // 물방증                    stats.put(MonsterStatus.MS_Pdr, new MonsterStatusEffect(skillId, (int) duration, x));                    break;                case 113: // 마방증                    stats.put(MonsterStatus.MS_Mdr, new MonsterStatusEffect(skillId, (int) duration, x));                    break;                case 114: // 힐                    if (lt != null && rb != null && skill && monster != null) {                        List<MapleMapObject> objects = getObjectsInRange(monster, MapleMapObjectType.MONSTER);                        final int hp = (getX() / 1000) * (int) (950 + 1050 * Math.random());                        for (MapleMapObject mons : objects) {                            ((MapleMonster) mons).heal(hp, getY(), true);                        }                    } else if (monster != null) {                        monster.heal(getX(), getY(), true);                    }                    break;                case 115: // 이속                    stats.put(MonsterStatus.MS_Speed, new MonsterStatusEffect(skillId, (int) duration, x));                    break;                case 120: // 스킬 봉인                    diseases.put(MapleBuffStat.Seal, new Pair<>(x, (int) duration));                    break;                case 121: // 암흑                    diseases.put(MapleBuffStat.Darkness, new Pair<>(x, (int) duration));                    break;                case 122:                    diseases.put(MapleBuffStat.Weakness, new Pair<>(x, (int) duration));                    break;                case 123:                    diseases.put(MapleBuffStat.Stun, new Pair<>(1, (int) duration));                    break;                case 124:                    diseases.put(MapleBuffStat.Curse, new Pair<>(x, (int) duration));                    break;                case 125:                    diseases.put(MapleBuffStat.Poison, new Pair<>(x, (int) duration));                    break;                case 126:                    diseases.put(MapleBuffStat.Slow, new Pair<>(x, (int) duration));                    break;                case 127:                    if (lt != null && rb != null && skill && monster != null && player != null) {                        for (MapleCharacter character : getPlayersInRange(monster, player)) {                            character.dispel();                        }                    } else if (player != null) {                        player.dispel();                    }                    break;                case 128:                    diseases.put(MapleBuffStat.Attract, new Pair<>(x, (int) duration));                    break;                case 129: // Banish                    if (monster != null && monster.getMap().getSquadByMap() == null) { //not pb/vonleon map                        if (monster.getEventInstance() != null && monster.getEventInstance().getName().indexOf("BossQuest") != -1) {                            break;                        }                        final BanishInfo info = monster.getStats().getBanishInfo();                        System.out.println(info.getMap());                        if (info != null) {                            if (lt != null && rb != null && skill && player != null) {                                for (MapleCharacter chr : getPlayersInRange(monster, player)) {                                    chr.changeMapBanish(info.getMap(), info.getPortal(), info.getMsg());                                }                            } else if (player != null) {                                player.changeMapBanish(info.getMap(), info.getPortal(), info.getMsg());                            }                        }                    }                    break;                case 131: { // Mist. 전깃줄이나 매그너스 가스 등.                    MapleMist mist = null;                    if (monster.getId() / 1000 == 8950) {                        mist = new MapleMist(new Rectangle(-684, -29, 1365, 15), monster, this, (int) duration);                    } else {                        mist = new MapleMist(calculateBoundingBox(monster.getTruePosition(), true), monster, this, (int) duration);                    }                    if (mist != null && monster != null && monster.getMap() != null) {                        monster.getMap().spawnMist(mist, false);                    }                    break;                }                case 132:                    diseases.put(MapleBuffStat.ReverseInput, new Pair<>(1, (int) duration));                    break;                case 133:                    diseases.put(MapleBuffStat.Undead, new Pair<>(x, (int) duration));                    break;                case 134:                    diseases.put(MapleBuffStat.StopPortion, new Pair<>(x, (int) duration)); // 불확실                    break;                case 135: // 그림자에 씌여 계속 움직이지 않으면 데미지를 입습니다.                    diseases.put(MapleBuffStat.StopMotion, new Pair<>(x, (int) duration));                    break;                case 136:                    diseases.put(MapleBuffStat.Fear, new Pair<>(x, (int) duration));                    break;                case 137:                    diseases.put(MapleBuffStat.Frozen, new Pair<>(x, (int) duration));                    break;                case 138:                    diseases.put(MapleBuffStat.DispelItemOption, new Pair<>(x, (int) duration));                    break;                case 140: // 공무                    stats.put(MonsterStatus.MS_PImmune, new MonsterStatusEffect(skillId, (int) duration, x));                    break;                case 141: // 마무                    stats.put(MonsterStatus.MS_MImmune, new MonsterStatusEffect(skillId, (int) duration, x));                    break;                case 142: // HardSkin                    stats.put(MonsterStatus.MS_Hardskin, new MonsterStatusEffect(skillId, (int) duration, x));                    break;                case 143: // 공반                    stats.put(MonsterStatus.MS_PImmune, new MonsterStatusEffect(skillId, (int) duration, x));                    stats.put(MonsterStatus.MS_PCounter, new MonsterStatusEffect(skillId, (int) duration, x));                    break;                case 144: // 마반                    stats.put(MonsterStatus.MS_MImmune, new MonsterStatusEffect(skillId, (int) duration, x));                    stats.put(MonsterStatus.MS_MCounter, new MonsterStatusEffect(skillId, (int) duration, x));                    break;                case 145: // 공/마반                    stats.put(MonsterStatus.MS_PImmune, new MonsterStatusEffect(skillId, (int) duration, x));                    stats.put(MonsterStatus.MS_MImmune, new MonsterStatusEffect(skillId, (int) duration, x));                    stats.put(MonsterStatus.MS_PCounter, new MonsterStatusEffect(skillId, (int) duration, x));                    stats.put(MonsterStatus.MS_MCounter, new MonsterStatusEffect(skillId, (int) duration, x));                    break;                case 146: // 무적                    if (monster.getId() != 8850010) {                        stats.put(MonsterStatus.MS_PowerImmune, new MonsterStatusEffect(skillId, (int) duration, x));                    }                    break;                case 150:                    stats.put(MonsterStatus.MS_Pad, new MonsterStatusEffect(skillId, (int) duration, x));                    break;                case 151:                    stats.put(MonsterStatus.MS_Mad, new MonsterStatusEffect(skillId, (int) duration, x));                    break;                case 152:                    stats.put(MonsterStatus.MS_Pdr, new MonsterStatusEffect(skillId, (int) duration, x));                    break;                case 153:                    stats.put(MonsterStatus.MS_Mdr, new MonsterStatusEffect(skillId, (int) duration, x));                    break;                case 154:                    stats.put(MonsterStatus.MS_Acc, new MonsterStatusEffect(skillId, (int) duration, x));                    break;                case 155:                    stats.put(MonsterStatus.MS_Eva, new MonsterStatusEffect(skillId, (int) duration, x));                    break;                case 156:                    stats.put(MonsterStatus.MS_Speed, new MonsterStatusEffect(skillId, (int) duration, x));                    break;                case 157:                    stats.put(MonsterStatus.MS_Seal, new MonsterStatusEffect(skillId, (int) duration, x)); //o.o                    break;                case 170: // 몹 사라지는거                    //false 일때만 보낸다...                    switch (skillLevel) {                        case 10: { // 빨강삐에르 내려찍기                            monster.setPosition(player.getTruePosition());                            monster.getMap().broadcastMessage(MobPacket.TeleportMonster(monster, false, 5, monster.getTruePosition()));                            break;                        }                        case 13: { // 벨룸 깊숨                            if (isFacingLeft) {                                monster.setPosition(new Point(965, 420));                                player.getClient().getSession().writeAndFlush(MobPacket.TeleportMonster(monster, false, 3, new Point(965, 420)));                            } else {                                monster.setPosition(new Point(-1750, 420));                                player.getClient().getSession().writeAndFlush(MobPacket.TeleportMonster(monster, false, 3, new Point(-1750, 420)));                            }                            monster.getMap().broadcastMessage(MobPacket.setAfterAttack(monster.getObjectId(), getAfterAttack(), getAfterAttackCount(), 30, isFacingLeft));                            monster.getMap().broadcastMessage(CWvsContext.getTopMsg("벨룸이 깊은 숨을 들이쉽니다."));                            break;                        }                        case 42: { // 칼 베어남기기                            List<MapleDelayedAttack> mda = new ArrayList<>();                            int x = (int) monster.getTruePosition().getX();                            boolean facingleft = monster.isFacingLeft();                            for (int i = 0; i < 3; ++i) {                                mda.add(new MapleDelayedAttack(monster, new Point(x + (i * 250 * (facingleft ? -1 : 1)), -113), Randomizer.rand(80, 130), facingleft));                            }                            monster.getMap().spawnDelayedAttack(monster, MobSkillFactory.getMobSkill(skillId, skillLevel), mda);                            break;                        }                        case 44:                        case 45:                        case 46:                        case 47: { // 내려찍기                            monster.getMap().spawnDelayedAttack(MobSkillFactory.getMobSkill(skillId, skillLevel), new MapleDelayedAttack(monster, new Point(monster.getTruePosition().x + (monster.isFacingLeft() ? -600 : 600), (monster.getId() == 8880100 || monster.getId() == 8880110) ? 0x10 : 0x11), monster.isFacingLeft()));                            break;                        }                        case 49: { // 확실하지 않음, 화염폭풍 (attack3로 연결되게 ㅇㅇ)                            monster.getMap().broadcastMessage(MobPacket.setAfterAttack(monster.getObjectId(), 2, 1, action, monster.isFacingLeft()));                            break;                        }                        case 50: { // 강력한 피해를 입혀 저지                            MobSkillFactory.getMobSkill(214, 14).applyEffect(player, monster, skill, isFacingLeft);                            break;                        }                        case 51: { // 피해 저지 성공 후 데미안 그로기 상태                            monster.getMap().broadcastMessage(MobPacket.demianRunaway(monster, (byte) 1, this, 0));                            break;                        }                        case 57: { // 윌 1페 텔포//                            monster.setPosition(player.getTruePosition());                            monster.getMap().broadcastMessage(MobPacket.TeleportMonster(monster, false, 12, monster.getTruePosition()));                            break;                        }                        case 58: { // 진 힐라                            monster.setPosition(player.getTruePosition());                            monster.getMap().broadcastMessage(MobPacket.TeleportMonster(monster, false, 2, monster.getTruePosition()));                            /*                            if (monster.getTruePosition().x >= -50 && monster.getTruePosition().x <= 50) {                             if (monster.getMap().getReqTouched() > 0) {                             monster.getMap().broadcastMessage(CField.JinHillah(8, player));                             }                             }*/                            break;                        }                        case 62: // 창조의 아이온                        case 64: { // 파괴의 얄다바오트                            Rectangle zone = new Rectangle(lt.x, lt.y, rb.x, rb.y);                            monster.setPosition(zone.getLocation());                            monster.getMap().broadcastMessage(CField.enforceMSG("통곡의 장벽이 솟아올라 공간을 잠식한다.", 265, 3000));                            monster.getMap().broadcastMessage(MobPacket.TeleportMonster(monster, true, 2, monster.getTruePosition()));                            monster.getMap().broadcastMessage(MobPacket.useFieldSkill(100008, 1));                            //custom Cooldown                            monster.setLastSkillUsed(this, System.currentTimeMillis(), 40000);                            MobTimer.getInstance().schedule(() -> {                                int[] pointz = {-2172, -1998, -1824, -1650, -1476, -1302, -1128, -954, -780, -606};                                int count = 0;                                for (MapleMonster mob : monster.getMap().getAllMonstersThreadsafe()) {                                    if (mob.getId() == 8880507) {                                        count++;                                    }                                }                                if (count < pointz.length) {                                    if (skillLevel == 62) {                                        monster.getMap().spawnMonsterOnGroundBelow(MapleLifeFactory.getMonster(8880507), new Point(pointz[count], 84));                                    } else {                                        monster.getMap().spawnMonsterOnGroundBelow(MapleLifeFactory.getMonster(8880508), new Point(pointz[count] * -1, 84));                                    }                                }                                monster.getMap().broadcastMessage(MobPacket.fieldSkillRemove(100008, 1));                            }, 2000);                            //보호막 패킷 추가                            monster.setBarrier(1000000000000L);                            monster.getMap().broadcastMessage(MobPacket.mobBarrier(monster.getObjectId(), 100)); // %값                            MapleMonster linkMob = monster.getMap().getMonsterById(monster.getStats().getHpLinkMob());                            monster.getMap().broadcastMessage(MobPacket.mobBarrierEffect(monster.getObjectId(), "UI/UIWindow8.img/BlackMageShield/mobEffect", "Sound/Etc.img/BlackMageShield", "UI/UIWindow8.img/BlackMageShield/mobEffect0"));                            if (linkMob != null) {                                linkMob.setBarrier(1000000000000L);                                linkMob.getMap().broadcastMessage(MobPacket.mobBarrier(linkMob.getObjectId(), 100)); // %값                            }                            MobTimer.getInstance().schedule(() -> {                                monster.setBarrier(0);                                monster.getMap().broadcastMessage(MobPacket.mobBarrier(monster.getObjectId(), 0));                                if (linkMob != null) {                                    linkMob.setBarrier(0);                                    linkMob.getMap().broadcastMessage(MobPacket.mobBarrier(linkMob.getObjectId(), 0));                                }                            }, 15000);                            break;                        }                        default: {                            monster.setPosition(player.getTruePosition());                            player.getClient().getSession().writeAndFlush(MobPacket.TeleportMonster(monster, false, 2, monster.getTruePosition()));                            break;                        }                    }                    break;                case 171: // 폭탄                    diseases.put(MapleBuffStat.TimeBomb, new Pair<>(x, (int) duration));                    break;                case 172: // 변이                    diseases.put(MapleBuffStat.Morph, new Pair<>(x, (int) duration));                    break;                case 173: // 지속 데미지                    diseases.put(MapleBuffStat.DarkTornado, new Pair<>(x, (int) duration));                    break;                case 174: // 데미안 바인드                    diseases.put(MapleBuffStat.Lapidification, new Pair<>(6, (int) duration));                    break;                case 175: // 데미지 증폭                    diseases.put(MapleBuffStat.DeathMark, new Pair<>(x, (int) duration));                    break;                case 176: // 범위 즉사 공격 (아카이럼 모니터 브레이크, 카오스 자쿰 공격 등)                    int value = 0,                     rId = 0;                    switch (skillLevel) {                        case 1:                        case 6:                            rId = 2708001;                            break;                        case 2:                        case 7:                            rId = 2708002;                            break;                        case 3:                        case 8:                            rId = 2708003;                            break;                        case 4:                        case 9:                            rId = 2708004;                            break;                        case 5:                            value = x;                            break;                        case 25:                        case 26:                        case 27:                        case 33:                        case 34: { // 자쿰                            value = 100;                            player.getMap().broadcastMessage(MobPacket.ZakumAttack(monster, monster.getStats().getSkeleton().get(0).left));                            break;                        }                        case 31: {                            value = 90;                            break;                        }                    }                    if (rId != 0 && monster != null && player != null) {                        MapleReactor react;                        for (final MapleMapObject remo : monster.getMap().getAllReactorsThreadsafe()) {                            react = (MapleReactor) remo;                            if (react.getReactorId() == rId) {                                react.hitReactor(player.getClient());                                break;                            }                        }                    }                    if (value > 0) {                        //범위 내에 캐릭터가 존재하면 데미지                        if (lt != null && rb != null && monster != null && player != null) {                            if (monster.getId() >= 8800103 && monster.getId() <= 8800106) {                                for (MapleCharacter character : getPlayersInRange(new Point(monster.getTruePosition().x - (110 * (monster.getId() - 8800102)), monster.getTruePosition().y), isFacingLeft, player)) {                                    character.addHP(-character.getStat().getCurrentMaxHp());                                    character.getClient().getSession().writeAndFlush(CField.trembleEffect(1, 0));                                    character.getMap().broadcastMessage(CField.screenAttack(monster.getId(), skillId, skillLevel, value));                                }                            } else if (monster.getId() >= 8800107 && monster.getId() <= 8800110) {                                for (MapleCharacter character : getPlayersInRange(new Point(monster.getTruePosition().x + (110 * (monster.getId() - 8800107)), monster.getTruePosition().y), isFacingLeft, player)) {                                    character.addHP(-character.getStat().getCurrentMaxHp());                                    character.getClient().getSession().writeAndFlush(CField.trembleEffect(1, 0));                                    character.getMap().broadcastMessage(CField.screenAttack(monster.getId(), skillId, skillLevel, value));                                }                            } else {                                for (MapleCharacter chr : player.getMap().getCharacters()) {                                    long damage = chr.getStat().getCurrentMaxHp() * value / 100;                                    chr.addHP(-damage);                                    chr.getClient().getSession().writeAndFlush(CField.trembleEffect(1, 0));                                    chr.getClient().getSession().writeAndFlush(CField.screenAttack(monster.getId(), skillId, skillLevel, damage));                                }                            }                        }                    }                    break;                case 177:                    diseases.put(MapleBuffStat.VenomSnake, new Pair<>(x, (int) duration));                    break;                case 178: // 익숙한 무언가                    break;                case 179: //                    diseases.put(MapleBuffStat.PainMark, new Pair<>(x, (int) duration));//            	player.getMap().broadcastMessage(MobPacket.SpeakingMonster(monster, 0, 0));                    break;                case 180: // 힐라 흡혈                    diseases.put(MapleBuffStat.VampDeath, new Pair<>((int) duration, (int) duration));                    diseases.put(MapleBuffStat.VampDeathSummon, new Pair<>((int) duration, (int) duration));                    player.getMap().broadcastMessage(MobPacket.SpeakingMonster(monster, 2, 0));                    break;                case 181:                    diseases.put(MapleBuffStat.Magnet, new Pair<>(x, (int) duration));                    diseases.put(MapleBuffStat.MagnetArea, new Pair<>(x, (int) duration));                    break;                case 182: // 아카이럼 수면가스?                    diseases.put(MapleBuffStat.GiveMeHeal, new Pair(this.x, (int)this.duration));                    break;                case 183: // 블러디 퀸 불꽃                    if (player.getDebuffValue(MapleBuffStat.FireBomb) == 3) {                        diseases.put(MapleBuffStat.FireBomb, new Pair<>(3 + 4, (int) duration));                    } else if (player.getDebuffValue(MapleBuffStat.FireBomb) == 7) {                        diseases.put(MapleBuffStat.FireBomb, new Pair<>(3 + 4 + 5, (int) duration));                    } else {                        diseases.put(MapleBuffStat.FireBomb, new Pair<>(3, (int) duration));                    }                    break;                case 184: // 반반 강제위치이동 (그림자 생성)                    diseases.put(MapleBuffStat.ReturnTeleport, new Pair<>((y << 16) + x, (int) duration)); //(player.getTruePosition().y << 8) + player.getTruePosition().x                    break;                case 186: // 장판                    if (skillLevel == 11) {                        monster.getMap().broadcastMessage(CField.enforceMSG("더스크 중심으로 주변의 에너지가 빠른 속도로 빨려 들어갑니다.", 249, 2000));                        MapleMist DustMist = new MapleMist(new Rectangle(-664, -940, 1326, 803), monster, this, (int) 7000);                        DustMist.setPosition(new Point(-45, -157));                        if (DustMist != null) {                            monster.getMap().spawnMist(DustMist, true);                        }                    } else if (player != null && lt != null && rb != null) {                        MapleMist mist = new MapleMist(calculateBoundingBox(player.getTruePosition(), player.isFacingLeft()), monster, this, (int) duration);                        if (skillLevel == 1) {                            mist = new MapleMist(new Rectangle(player.getPosition().x, 52, player.getPosition().x + 500, 140), monster, this, (int) duration);                            mist.setPosition(player.getPosition());                        } else if (skillLevel == 2) {                            mist = new MapleMist(new Rectangle(monster.getPosition().x - 1000, -275, monster.getPosition().x + 1500, 470), monster, this, (int) duration);                            mist.setPosition(monster.getPosition());                            mist.setDelay(7);                        } else if (skillLevel == 5) { //벨룸 끌땅                            if (isFacingLeft) {                                mist = new MapleMist(new Rectangle(-1695, -357, 2060, 810), monster, this, (int) duration);                                mist.setPosition(new Point(965, 443));                            } else {                                mist = new MapleMist(new Rectangle(-1110, -357, 2060, 810), monster, this, (int) duration);                                mist.setPosition(new Point(-1710, 443));                            }                        } else if (skillLevel == 6) {//벨룸 끌땅                            mist = new MapleMist(new Rectangle(-1870, 133, 3020, 330), monster, this, (int) duration);                            if (isFacingLeft) {                                mist.setPosition(new Point(965, 443));                            } else {                                mist.setPosition(new Point(-1710, 443));                            }                        }                        if (mist != null) {                            monster.getMap().spawnMist(mist, true);                        }                    }                    break;                case 187:                    break;                case 188: // 블러디 퀸 거울 유혹                    duration = 30000;                    int goRight = 1;                    if (monster.getTruePosition().getX() >= player.getTruePosition().getX()) {                        goRight = 2;                    }                    if (player.getBuffedValue(MapleBuffStat.IndieNotDamaged) != null || player.getBuffedValue(MapleBuffStat.NotDamaged) != null) {                    } else {                        diseases.put(MapleBuffStat.Slow, new Pair<>(50, (int) duration));                        diseases.put(MapleBuffStat.Stance, new Pair<>(100, (int) duration));                        diseases.put(MapleBuffStat.Attract, new Pair<>(goRight, (int) duration));                    }                    break;                case 189: { // 피에르 모자 빨간색                    diseases.put(MapleBuffStat.CapDebuff, new Pair<>(100, (int) duration));                    break;                }                case 190: { // 피에르 모자 파란색                    diseases.put(MapleBuffStat.CapDebuff, new Pair<>(200, (int) duration));                    break;                }                case 191: // 반반 타임워프                    Point clockPos = new Point(Randomizer.nextInt(rb.x - lt.x) + lt.x, monster.getTruePosition().y);                    Rectangle box = calculateBoundingBox(monster.getTruePosition(), true);                    MapleMist clock = new MapleMist(box, monster, this, (int) duration);                    clock.setPosition(clockPos);                    monster.getMap().spawnMist(clock, false);                    monster.getMap().broadcastMessage(CWvsContext.getTopMsg("시간의 틈새에 '균열'이 발생하였습니다."));                    break;                case 200:                case 201:                    if (monster == null) {                        return;                    }                    if (skillLevel == 199) {                        if (monster.getMap().lucidButterflyCount >= 40) {                            monster.setNextSkill(238);                            monster.setNextSkillLvl(9);                            return;                        }                    }                    if (skillLevel == 197) { // 1페                        int i = Randomizer.nextInt(11);                        if (i != 10) {                            long time = System.currentTimeMillis();                            MobSkill msi = monster.getSkills().get(i + 5);                            if ((time - monster.getLastSkillUsed(msi.getSkillId(), msi.getSkillLevel())) >= 0) {                                monster.setNextSkill(msi.getSkillId());                                monster.setNextSkillLvl(msi.getSkillLevel());                            }                            toSummon.clear();                            toSummon.add(8880165);                            toSummon.add(8880168);                            toSummon.add(8880169);                            //  return; //대체왜? 이러면 나비 한번만 나오는데                        }                    }                    if (skillLevel == 198 || skillLevel == 223) { // 1페                        toSummon.clear();                        if (monster.getId() == 8880140) {                            if (Randomizer.nextBoolean()) {                                toSummon.add(8880157);                            } else {                                toSummon.add(8880157);                                for (int i = 0; i < Randomizer.rand(1, 3); i++) {                                    toSummon.add(8880160);                                }                            }                        } else if (monster.getId() == 8880141) {                            toSummon.add(8880184);                            toSummon.add(8880185);                            for (int i = 0; i < Randomizer.rand(2, 5); i++) {                                toSummon.add(8880180);                            }                        }                    }                    if (skillLevel == 199) { // 2페                        if (monster.getMap().isShootTime) {                            return;                        }                        toSummon.clear();                        if (monster.getId() == 8880150) {                            if (Randomizer.nextBoolean()) {                                toSummon.add(8880170);                            } else {                                toSummon.add(8880175);                                toSummon.add(8880178);                                toSummon.add(8880179);                            }                        } else if (monster.getId() == 8880151) {                            if (Randomizer.nextBoolean()) {                                toSummon.add(8880182);                            } else {                                toSummon.add(8880175);                                toSummon.add(8880178);                                toSummon.add(8880179);                            }                        }                    }                    if (skillId == 200 && skillLevel == 251) { // 하드 힐라                        player.getMap().broadcastMessage(MobPacket.SpeakingMonster(monster, 3, 0));                        stats.put(MonsterStatus.MS_ExchangeAttack, new MonsterStatusEffect(skillId, (int) duration, 1));                    }                    for (Integer mobId : getSummons()) {                        MapleMonster toSpawn = null;                        try {                            toSpawn = MapleLifeFactory.getMonster(GameConstants.getCustomSpawnID(monster.getId(), mobId));                        } catch (RuntimeException e) { //monster doesn't exist                            continue;                        }                        if (toSpawn == null) {                            continue;                        }                        toSpawn.setPosition(monster.getTruePosition());                        int ypos = (int) monster.getTruePosition().getY(), xpos = (int) monster.getTruePosition().getX();                        if (skillLevel == 197 || skillLevel == 198 || skillLevel == 223) {//루시드 버섯 골렘소환                            if (toSpawn.getId() == 8880160 || toSpawn.getId() == 8880180) {                                int randX = Randomizer.rand(346, 1693);                                xpos = randX;                            }                        }                        if (skillId == 201 && skillLevel == 49) { // 카벨 꼬리                            xpos = player.getTruePosition().x;                            ypos = player.getTruePosition().y;                        }                        if (getAfterDead() > 0) {                            toSpawn.setHp(monster.getHp());                            for (MobSkill sk : toSpawn.getSkills()) {                                if (sk.getAfterDead() > 0) {                                    toSpawn.setLastSkillUsed(sk, System.currentTimeMillis(), 40 * 1000);                                }                            }                            monster.getMap().killMonster(monster, player, false, false, (byte) 0);                        }                        switch (mobId) {                            case 8500003: // Pap bomb high                                toSpawn.setFh((int) Math.ceil(Math.random() * 19.0));                                ypos = -590;                                break;                            case 8500004: // Pap bomb                                //Spawn between -500 and 500 from the monsters X position                                xpos = (int) (monster.getTruePosition().getX() + Math.ceil(Math.random() * 1000.0) - 500);                                ypos = (int) monster.getTruePosition().getY();                                break;                            case 8510100: //Pianus bomb                                if (Math.ceil(Math.random() * 5) == 1) {                                    ypos = 78;                                    xpos = (int) (0 + Math.ceil(Math.random() * 5)) + ((Math.ceil(Math.random() * 2) == 1) ? 180 : 0);                                } else {                                    xpos = (int) (monster.getTruePosition().getX() + Math.ceil(Math.random() * 1000.0) - 500);                                }                                break;                            case 8820007: //mini bean                                continue;                        }                        // Get spawn coordinates (This fixes monster lock)                        // TODO get map left and right wall.                        switch (monster.getMap().getId()) {                            case 230040420: // Pianus map                                if (xpos < -239) {                                    xpos = (int) (-239 + Math.ceil(Math.random() * 150));                                } else if (xpos > 371) {                                    xpos = (int) (371 - Math.ceil(Math.random() * 150));                                }                                break;                        }                        if (skillLevel == 139 || skillLevel == 83) { // 스우                            switch (toSpawn.getId() % 10) {                                case 3:                                    xpos = 507;                                    ypos = -248;                                    break;                                case 4:                                    xpos = -420;                                    ypos = -421;                                    break;                                case 5:                                    xpos = -511;                                    ypos = -250;                                    break;                                case 7:                                    xpos = 417;                                    ypos = -423;                                    break;                            }                        }                        if (skillId == 201 && skillLevel == 237) {                            if (monster.isSkillForbid()) {                                continue;                            } else if (monster.getMap().getMonsterById(mobId) == null) {                                xpos = -710;                                ypos = 200;                            } else {                                xpos = 720;                                ypos = 200;                            }                        }                        if (skillLevel == 47) { //유혹거울                            boolean isMinus = Randomizer.isSuccess(50);                            int randX = Randomizer.rand(100, 500);                            if (isMinus) {                                xpos = monster.getPosition().x - randX;                            } else {                                xpos = monster.getPosition().x + randX;                            }                        }                        if (skillLevel == 48) {//하트 뿅뿅                            boolean isMinus = Randomizer.isSuccess(50);                            int randX = Randomizer.rand(0, 700);                            if (isMinus) {                                xpos = player.getPosition().x - randX;                            } else {                                xpos = player.getPosition().x + randX;                            }                            toSpawn.setSpawnTime(System.currentTimeMillis());                        }                        toSpawn.setSpawnTime(System.currentTimeMillis());                        int objectId = monster.getMap().spawnMonsterWithEffect(toSpawn, getSpawnEffect() == 77 ? 1 : getSpawnEffect(), monster.getMap().calcPointBelow(new Point(xpos, ypos - 1)));                        if (isMobGroup()) {                            if (!monster.getSpawnList().contains(toSpawn.getId())) {                                toSpawn.setMobGroup(true);                                monster.getSpawnList().add(toSpawn.getId());                                break;                            } else {                                continue;                            }                        }                        if (mobId == 8880306) {                            MapTimer.getInstance().schedule(() -> {                                if (monster.getController() != null) {                                    if (monster.getMap().getMonsterById(8880306) != null) {                                        monster.getMap().killMonster(8880306);                                    }                                }                            }, 10000);                        }                        if (skillId == 201 && skillLevel == 237) {                            MapTimer.getInstance().schedule(() -> {                                if (monster != null && monster.getController() != null && monster.getMap().getMonsterById(8880306) == null) {                                    MobSkill msi = MobSkillFactory.getMobSkill(201, 237);                                    msi.applyEffect(null, monster, true, monster.isFacingLeft());                                }                            }, 20000);                        }                    }                    break;                case 202: // 피에르 불장판 spawnmist                    break;                case 203: // 반반 차원이동/*            	MapleMap target = player.getClient().getChannelServer().getMapFactory().getMap(monster.getMap().getId() + 10);                     target.killAllMonsters(false);            	                     if (monster != null) {                     Point pos = new Point(Randomizer.nextInt(rb.x - lt.x) + lt.x, monster.getTruePosition().y);                     target.spawnFakeMonsterOnGroundBelow(MapleLifeFactory.getMonster(8910001), pos);                     monster.getMap().broadcastMessage(CWvsContext.spawnPortal(monster.getMap().getId(), target.getId(), skillId, pos));	            	                     MobTimer.getInstance().schedule(() -> {                     for (MaplePartyCharacter pc : player.getParty().getMembers()) {                     MapleCharacter chr = player.getClient().getChannelServer().getPlayerStorage().getCharacterById(pc.getId());                     if (chr != null) {                     chr.setDeadEffect(true);                     chr.addHP(-chr.getStat().getCurrentMaxHp());                     }                     }                     }, 15700);                     }*/                    break;                case 205:                    break;                case 206:                    break;                case 207:                    break;                case 208:                    break;                case 209:                    break;                case 211: { // 스우//            	MapleMist mist = new MapleMist(calculateBoundingBox(monster.getTruePosition(), true), monster, this, (int) duration);                    //              if (mist != null) {                    //                monster.getMap().spawnMist(mist, false);                    //          }                    break;                }                case 212: // 공증                    stats.put(MonsterStatus.MS_Pad, new MonsterStatusEffect(skillId, (int) duration, x));                    break;                case 213:                    switch (skillLevel) {                        case 10:                            setMobSkillDelay(player, monster, 2220, (short) 0, isFacingLeft);                            break;                        case 13:                            setMobSkillDelay(player, monster, 2040, (short) 0, isFacingLeft);                            break;                        case 14:                            setMobSkillDelay(player, monster, 1950, (short) 0, isFacingLeft);                            break;                        case 15:                            setMobSkillDelay(player, monster, 2160, (short) 0, isFacingLeft);                            break;                    }                    break;                case 214: // 게이지 쓰는 스킬들                    int time = 0;                    if (skillLevel == 13) {                        time = 30000;                        /*            		MobTimer.getInstance().schedule(() -> {                         for (MobSkill sk : monster.getSkills()) {                         if (sk.getSkillId() == 201) {                         sk.applyEffect(player, monster, true, isFacingLeft);                         monster.getMap().killMonster(monster);                         return;                         }                         }                         }, time);*/                    } else if (skillLevel == 14) {                        time = 10000;                        player.getMap().broadcastMessage(CField.enforceMSG("데미안이 타락한 세계수의 힘을 폭주시키기 전에 큰 피해를 입혀 저지해야 합니다.", 216, 9500000));                        diseases.put(MapleBuffStat.Lapidification, new Pair<>(x, (int) 10000));                        for (MapleCharacter chr : player.getMap().getAllCharactersThreadsafe()) {                            chr.giveDebuff(diseases, this);                        }                    }                    player.getMap().broadcastMessage(MobPacket.demianRunaway(monster, (byte) 0, this, time));                    break;                case 215: // 데미안 똥떨구기                    for (int z = 1; z <= 3; ++z) {                        MobTimer.getInstance().schedule(() -> {                            //int[] obs                            int[] obsplusx = {379, -5, -388};                            int[] angle = {642, 514, 642};                            int[] unk = {323, 0, 36};                            List<Obstacle> obs = new ArrayList<>();                            for (int i = 0; i < 3; i++) {                                Obstacle ob = new Obstacle(skillLevel == 2 ? 58 : 59, new Point(monster.getPosition().x, -505), new Point(monster.getPosition().x + obsplusx[i], skillLevel == 2 ? 16 : 17), 50, 90, 539, 105, 1, angle[i], unk[i]);                                obs.add(ob);                            }                            player.getMap().broadcastMessage(MobPacket.createObstacle(monster, obs, (byte) 4));                        }, (z * 2000) - 1000);                        MobTimer.getInstance().schedule(() -> {                            //int[] obs                            int[] obsplusx = {496, 207, 0, -208, -497};                            int[] angle = {714, 553, 514, 555, 714};                            int[] unk = {316, 338, 0, 22, 44};                            List<Obstacle> obs = new ArrayList<>();                            for (int i = 0; i < 5; i++) {                                Obstacle ob = new Obstacle(skillLevel == 2 ? 58 : 59, new Point(monster.getPosition().x, -505), new Point(monster.getPosition().x + obsplusx[i], skillLevel == 2 ? 16 : 17), 50, 90, 964, 76, 1, angle[i], unk[i]);                                obs.add(ob);                            }                            player.getMap().broadcastMessage(MobPacket.createObstacle(monster, obs, (byte) 4));                        }, z * 2000);                    }                    break;                case 216:                    break;                case 217:                    setMobSkillDelay(player, monster, 1920, (short) 0, isFacingLeft);                    break;                case 219:                    break;                case 220: // 공/마반                    stats.put(MonsterStatus.MS_PImmune, new MonsterStatusEffect(skillId, (int) duration, x));                    stats.put(MonsterStatus.MS_MImmune, new MonsterStatusEffect(skillId, (int) duration, x));                    stats.put(MonsterStatus.MS_PCounter, new MonsterStatusEffect(skillId, (int) duration, x));                    stats.put(MonsterStatus.MS_MCounter, new MonsterStatusEffect(skillId, (int) duration, x));                    break;                case 221: // 스킬 봉인                    diseases.put(MapleBuffStat.Seal, new Pair<>(x, (int) duration));                    break;                case 222: // 데미지 감소 구체                    break;                case 223: // 스우 레이저                    if (!monster.getStati().containsKey(MonsterStatus.MS_Laser)) {                        stats.put(MonsterStatus.MS_Laser, new MonsterStatusEffect(skillId, (int) duration));                    } else {                        for (MobSkill sk : monster.getSkills()) {                            if (sk.getSkillId() == 201) {                                sk.applyEffect(player, monster, true, isFacingLeft);                                return;                            }                        }                    }                    break;                case 226: // 스우 공중에 띄우기                    player.getMap().broadcastMessage(CField.airBone(player, monster, skillId, skillLevel, -1400));                    break;                case 227: { // 스우 끌어당기기//            	MapleMist mist = new MapleMist(calculateBoundingBox(monster.getTruePosition(), true), monster, this, (int) duration);                    //              if (mist != null) {                    //                monster.getMap().spawnMist(mist, false);                    //          }                    break;                }                case 228: { // 스우 레이저 방향 전환                    break;                }                case 230: // 스우 공중 공격                    break;                case 231: // 우르스 사망구조 요청                    break;                case 232: // 우르스 흙구조 요청                    break;                case 234: // 우르스, 루시드 폭탄                    diseases.put(MapleBuffStat.Contagion, new Pair<>(x, (int) duration));                    break;                case 235: // 자쿰                    break;                case 237: // 데미안 낙인                    duration = 0;                    player.Stigma++;                    Map<MapleBuffStat, Pair<Integer, Integer>> dds = new HashMap<>();                    dds.put(MapleBuffStat.Stigma, new Pair<>(player.Stigma, 237));                    if (player.Stigma == 7) {                        player.Stigma = 0;                        player.addHP(-player.getStat().getCurrentMaxHp());                        player.getMap().broadcastMessage(MobPacket.CorruptionChange((byte) 0, player.getMap().getStigmaDeath()));                        player.getMap().broadcastMessage(CField.environmentChange("Effect/OnUserEff.img/demian/screen", 4));                        MapleFlyingSword mfs = new MapleFlyingSword(1, monster);                        player.getMap().spawnFlyingSword(mfs);                        player.getMap().setNewFlyingSwordNode(mfs, monster.getTruePosition());                        player.getClient().getSession().writeAndFlush(BuffPacket.cancelBuff(dds, player));                        player.getMap().broadcastMessage(player, BuffPacket.cancelForeignBuff(player, dds), false);                        player.getMap().broadcastMessage(MobPacket.addStigma(player, 0));                    } else {                        player.getClient().getSession().writeAndFlush(BuffPacket.giveDisease(dds, this, player));                        player.getMap().broadcastMessage(player, BuffPacket.giveForeignDeBuff(player, dds), false);                        player.getMap().broadcastMessage(MobPacket.addStigma(player, 1));                        player.getClient().getSession().writeAndFlush(CField.specialMapSound("SoundEff/BossDemian/incStigma"));                    }                    return;                case 238: // 루시드 전용                    switch (skillLevel) {                        case 1://Flower Trap                        case 2:                        case 3:                            player.getMap().broadcastMessage(BossLucid.doFlowerTrapSkill(skillLevel, Randomizer.nextInt(3), 1000, 48, Randomizer.nextBoolean())); // ok                            break;                        case 4://Fairy Dust ok                        case 10: // okay                            //Oh, I'm fairly serious.                            List<FairyDust> fairyDust = new ArrayList<FairyDust>() {                                {                                    int x, s, s2, v, v2, w, w2, u = 2640;                                    if (skillLevel == 4) {                                        s = 180;                                        s2 = 240;                                        v = 100;                                        v2 = 5;                                        w = 3;                                        w2 = 1;                                        x = 40;                                    } else {                                        s = 30;                                        s2 = 330;                                        v = 250;                                        v2 = 100;                                        w = 6;                                        w2 = 3;                                        x = 5;                                    }                                    for (int i = 0, max = Randomizer.rand(w, w + w2); i < max; i++) {                                        x += Randomizer.nextInt(x);                                        add(new FairyDust(Randomizer.nextInt(3), u, v + Randomizer.nextInt(v2), x + Randomizer.rand(s, s2)));                                    }                                }                            };                            player.getMap().broadcastMessage(BossLucid.doFairyDustSkill(skillLevel, fairyDust));                            if (Randomizer.isSuccess(30)) {                                player.getMap().broadcastMessage(CField.enforceMSG("저 바람을 맞으면 꿈이 더 강해질 겁니다!", 222, 2000));                            }                            break;                        case 5://Laser Rain                            List<Integer> laserIntervals = new ArrayList<Integer>() {                                {                                    for (int i = 0; i < 15; i++) {                                        add(500);                                    }                                }                            };                            player.getMap().broadcastMessage(CField.enforceMSG("루시드가 강력한 공격을 사용하려 합니다!", 222, 2000));                            player.getMap().broadcastMessage(BossLucid.doLaserRainSkill(4500, laserIntervals)); // ok                            break;                        case 6://Forced Teleport ok                            player.getClient().getSession().writeAndFlush(BossLucid.doForcedTeleportSkill(Randomizer.nextInt(8)));//let's abuse the controller                            break;                        case 7://Dragon ok                            boolean isLeft = Randomizer.isSuccess(70);                            if (monster.getMap().getId() == 450004150 || monster.getMap().getId() == 450004450) {//450004150?                                player.getMap().broadcastMessage(BossLucid.createDragon(1, 0, 0, 0, 0, isLeft));                            } else {                                int createPosX = isLeft ? -138 : 1498;                                int createPosY = Randomizer.nextBoolean() ? -1312 : 238;                                int posX = createPosX;                                int posY = monster.getPosition().y;                                player.getMap().broadcastMessage(BossLucid.createDragon(2, posX, posY, createPosX, createPosY, isLeft));                            }                            player.getMap().broadcastMessage(CField.enforceMSG("루시드가 강력한 소환수를 소환했습니다!", 222, 2000));                            break;                        case 8://Rush                            player.getMap().broadcastMessage(CField.enforceMSG("루시드가 강력한 공격을 사용하려 합니다!", 222, 2000));                            player.getMap().broadcastMessage(BossLucid.doRushSkill()); // ok                            break;                        case 9://Welcome Barrage ok                            if (player.getMap().lucidButterflyCount <= 0) {                                return;                            }                            if (monster.isAlive()) {                                player.getMap().lucidButterflyCount = 0;                                player.getMap().isShootTime = true;                                player.getMap().killButterflys(player.getMap().getAllButterFly());                                player.getMap().broadcastMessage(BossLucid.setButterflyAction(Butterfly.Mode.MOVE, 600, -500));                                player.getMap().broadcastMessage(BossLucid.setStainedGlassOnOff(false, FieldLucid.STAINED_GLASS));                                player.getMap().broadcastMessage(BossLucid.setFlyingMode(true));                                player.getMap().broadcastMessage(BossLucid.doBidirectionShoot(50, Randomizer.rand(30, 50), 8000, 20));                                player.getMap().broadcastMessage(BossLucid.doSpiralShoot(10, 135, 13, Randomizer.rand(3, 10), 3500, Randomizer.rand(15, 25), 10, 1));                                player.getMap().broadcastMessage(BossLucid.doWelcomeBarrageSkill(2));                                MobTimer.getInstance().schedule(() -> {                                    player.getMap().broadcastMessage(BossLucid.setStainedGlassOnOff(true, FieldLucid.STAINED_GLASS));                                    player.getMap().broadcastMessage(BossLucid.setFlyingMode(false));                                    player.getMap().isShootTime = false;                                }, 15700);                            }                            break;                    }                    break;                case 241: // 파풀라투스 전용                    switch (skillLevel) {                        case 1:                            setMobSkillDelay(player, monster, 720, (short) 0, isFacingLeft);                            break;                        case 2:                            setMobSkillDelay(player, monster, 720, (short) 0, isFacingLeft);                            break;                    }                    break;                case 242: // 윌 전용                    switch (skillLevel) {                        case 1: // 1페 다리찍기                        case 2: // 2페 다리찍기                        case 3: // 3페 다리찍기                            int id = 0;                            if (monster.getId() == 8880321 || monster.getId() == 8880322) {                                id = monster.getId() - 18;                            } else if (monster.getId() == 8880323 || monster.getId() == 8880324) {                                id = monster.getId() - 22;                            } else if (monster.getId() == 8880353 || monster.getId() == 8880354) {                                id = monster.getId() - 12;                            } else {                                id = monster.getId() - 8;                            }                            int size = Randomizer.rand(17, 23);                            List<Triple<Integer, Integer, Integer>> idx = new ArrayList<Triple<Integer, Integer, Integer>>() {                                {                                    for (int i = 1; i <= size; i++) {                                        add(new Triple<>(i, (1800 * (1 + (i / 6))), -650 + (130 * Randomizer.rand(1, 9))));                                    }                                }                            };                            player.getMap().broadcastMessage(BossWill.WillSpiderAttack(id, skillId, skillLevel, 0, idx));                            break;                        case 4: // 1페이즈 : 주시하는 눈                            monster.getMap().broadcastMessage(CField.enforceMSG("눈동자를 공격해서 다른 공간에 달빛을 흘려보내세요. 어서 달빛 보호막을 생성해야 해요.", 245, 28000));                            monster.getMap().broadcastMessage(BossWill.willUseSpecial());                            List<Integer> ids = new ArrayList<Integer>() {                                {                                    for (int i = 0; i < 6; i++) {                                        add(i);                                    }                                }                            };                            for (MapleMonster mob : monster.getMap().getAllMonstersThreadsafe()) {                                mob.getMap().broadcastMessage(MobPacket.BlockAttack(mob, ids));                                mob.setSkillForbid(true);                                mob.setUseSpecialSkill(true);                            }                            for (MapleCharacter chr : monster.getMap().getAllCharactersThreadsafe()) {                                chr.getClient().getSession().writeAndFlush(BossWill.WillSpiderAttack(monster.getId(), skillId, skillLevel, Randomizer.rand(1, 2), null));                            }                            monster.getMap().spawnMonsterOnGroundBelow(MapleLifeFactory.getMonster(8880305), new Point(0, -2020));                            monster.getMap().spawnMonsterOnGroundBelow(MapleLifeFactory.getMonster(8880305), new Point(0, 159));                            MobTimer.getInstance().schedule(() -> {                                monster.getMap().killMonster(8880305);                                List<MapleMist> mists = new ArrayList<>();                                List<MapleCharacter> targets = new ArrayList<>();                                for (MapleMist mi : monster.getMap().getAllMistsThreadsafe()) {                                    if (mi.getMobSkill() != null && mi.getMobSkill().getSkillId() == skillId && mi.getMobSkill().getSkillLevel() == skillLevel) {                                        mists.add(mi);                                    } else if (mi.getSource() != null && (mi.getSource().getSourceId() == 400031039 || mi.getSource().getSourceId() == 400031040)) {                                        mists.add(mi);                                    }                                }                                for (MapleCharacter chr : monster.getMap().getAllCharactersThreadsafe()) {                                    boolean add = true;                                    chr.getClient().getSession().writeAndFlush(EffectPacket.showWillEffect(chr, 1, skillId, skillLevel));                                    chr.getClient().getSession().writeAndFlush(BossWill.WillSpiderAttack(monster.getId(), skillId, skillLevel, 0, null));                                    for (MapleMist mist : mists) {                                        if (mist.getBox().contains(chr.getTruePosition())) {                                            add = false;                                        }                                    }                                    if (add) {                                        targets.add(chr);                                    }                                }                                for (MapleCharacter chr : targets) {                                    if (chr.getBuffedEffect(MapleBuffStat.HolyMagicShell) != null) {                                        if (chr.getHolyMagicShell() > 0) {                                            chr.setHolyMagicShell((byte) (chr.getHolyMagicShell() - 1));                                            Map<MapleBuffStat, Pair<Integer, Integer>> statups = new HashMap<>();                                            statups.put(MapleBuffStat.HolyMagicShell, new Pair<>((int) chr.getHolyMagicShell(), (int) chr.getBuffLimit(chr.getBuffSource(MapleBuffStat.HolyMagicShell))));                                            chr.getClient().getSession().writeAndFlush(BuffPacket.giveBuff(statups, chr.getBuffedEffect(MapleBuffStat.HolyMagicShell), chr));                                        } else {                                            chr.cancelEffectFromBuffStat(MapleBuffStat.HolyMagicShell);                                        }                                    } else if (chr.getBuffedEffect(MapleBuffStat.WindWall) != null) {                                        int windWall = (int) Math.max(0, chr.getBuffedValue(MapleBuffStat.WindWall) - (100 * chr.getBuffedEffect(MapleBuffStat.WindWall).getZ()));                                        if (windWall > 0) {                                            chr.setBuffedValue(MapleBuffStat.WindWall, windWall);                                            Map<MapleBuffStat, Pair<Integer, Integer>> statups = new HashMap<>();                                            statups.put(MapleBuffStat.WindWall, new Pair<>(windWall, (int) chr.getBuffLimit(400031030)));                                            chr.getClient().getSession().writeAndFlush(BuffPacket.giveBuff(statups, chr.getBuffedEffect(MapleBuffStat.WindWall), chr));                                        } else {                                            chr.cancelEffectFromBuffStat(MapleBuffStat.WindWall);                                        }                                    } else if (chr.getBuffedEffect(MapleBuffStat.TrueSniping) == null && chr.getBuffedEffect(MapleBuffStat.Etherealform) == null && chr.getBuffedEffect(MapleBuffStat.IndieNotDamaged) == null && chr.getBuffedEffect(MapleBuffStat.NotDamaged) == null) {                                        int reduce = 0;                                        if (chr.getBuffedEffect(MapleBuffStat.IndieDamageReduce) != null) {                                            reduce = chr.getBuffedValue(MapleBuffStat.IndieDamageReduce);                                        } else if (chr.getBuffedEffect(MapleBuffStat.IndieBarrierDischarge) != null) {                                            reduce = -chr.getBuffedValue(MapleBuffStat.IndieBarrierDischarge);                                        }                                        chr.addHP(-chr.getStat().getCurrentMaxHp() * (100 - reduce) / 100);                                    }                                }                                if (monster.isUseSpecialSkill()) {                                    List<Integer> newHpList = new ArrayList<>();                                    if (monster.getHPPercent() <= 67 && monster.getWillHplist().contains(666)) {                                        newHpList.add(333);                                        newHpList.add(3);                                    } else if (monster.getHPPercent() <= 34 && monster.getWillHplist().contains(333)) {                                        newHpList.add(3);                                    } else if (monster.getHPPercent() <= 1 && monster.getWillHplist().contains(3)) {                                        //                                    } else {                                        newHpList.add(666);                                        newHpList.add(333);                                        newHpList.add(3);                                    }                                    monster.setWillHplist(newHpList);                                    monster.getMap().broadcastMessage(BossWill.setWillHp(monster.getWillHplist(), monster.getMap(), monster.getId(), monster.getId() + 3, monster.getId() + 4));                                    MobSkillFactory.getMobSkill(242, 8).applyEffect(player, monster, skill, isFacingLeft);                                } else {                                    for (MapleMonster mob : monster.getMap().getAllMonstersThreadsafe()) {                                        mob.getMap().broadcastMessage(MobPacket.BlockAttack(mob, new ArrayList<>()));                                        mob.setSkillForbid(false);                                        mob.setUseSpecialSkill(false);                                    }                                    monster.setNextSkill(0);                                    monster.setNextSkillLvl(0);                                }                                MobTimer.getInstance().schedule(() -> {                                    MobSkillFactory.getMobSkill(242, 15).applyEffect(player, monster, skill, isFacingLeft);                                }, 11000);                            }, 30000);                            break;                        case 5: // 1페이즈 : 공간 붕괴                            if (monster.getId() == 8880300 || monster.getId() == 8880340) {                                MapleMonster will1 = monster.getMap().getMonsterById(monster.getId() + 3);                                MapleMonster will2 = monster.getMap().getMonsterById(monster.getId() + 4);                                long hp1 = 0, hp2 = 0;                                if (will1 != null) {                                    hp1 = will1.getHp();                                }                                if (will2 != null) {                                    hp2 = will2.getHp();                                }                                long newhp = Math.max(hp1, hp2);                                monster.setHp(newhp);                                if (will1 != null) {                                    will1.setHp(newhp);                                }                                if (will2 != null) {                                    will2.setHp(newhp);                                }                                monster.getMap().broadcastMessage(BossWill.setWillHp(monster.getWillHplist(), monster.getMap(), monster.getId(), monster.getId() + 3, monster.getId() + 4));                            }                            int type = Randomizer.nextInt(2);                            monster.getMap().broadcastMessage(MobPacket.showBossHP(monster));                            //눈동자 패킷                            monster.getMap().broadcastMessage(BossWill.WillSpiderAttack(monster.getId(), skillId, skillLevel, type, null));                            MobTimer.getInstance().schedule(() -> {                                List<MapleMist> mists = new ArrayList<>();                                List<MapleCharacter> targets = new ArrayList<>();                                for (MapleMist mi : monster.getMap().getAllMistsThreadsafe()) {                                    if (mi.getSource() != null && (mi.getSource().getSourceId() == 400031039 || mi.getSource().getSourceId() == 400031040)) {                                        mists.add(mi);                                    }                                }                                for (MapleCharacter chr : monster.getMap().getAllCharactersThreadsafe()) {                                    boolean add = true;                                    chr.getClient().getSession().writeAndFlush(EffectPacket.showWillEffect(chr, 1, skillId, skillLevel));                                    for (MapleMist mist : mists) {                                        if (mist.getBox().contains(chr.getTruePosition())) {                                            add = false;                                        }                                    }                                    if (add) {                                        targets.add(chr);                                    }                                }                                for (MapleCharacter chr : targets) {                                    if (chr.getBuffedEffect(MapleBuffStat.HolyMagicShell) != null) {                                        if (chr.getHolyMagicShell() > 0) {                                            chr.setHolyMagicShell((byte) (chr.getHolyMagicShell() - 1));                                            Map<MapleBuffStat, Pair<Integer, Integer>> statups = new HashMap<>();                                            statups.put(MapleBuffStat.HolyMagicShell, new Pair<>((int) chr.getHolyMagicShell(), (int) chr.getBuffLimit(chr.getBuffSource(MapleBuffStat.HolyMagicShell))));                                            chr.getClient().getSession().writeAndFlush(BuffPacket.giveBuff(statups, chr.getBuffedEffect(MapleBuffStat.HolyMagicShell), chr));                                        } else {                                            chr.cancelEffectFromBuffStat(MapleBuffStat.HolyMagicShell);                                        }                                    } else if (chr.getBuffedEffect(MapleBuffStat.WindWall) != null) {                                        int windWall = (int) Math.max(0, chr.getBuffedValue(MapleBuffStat.WindWall) - (100 * chr.getBuffedEffect(MapleBuffStat.WindWall).getZ()));                                        if (windWall > 0) {                                            chr.setBuffedValue(MapleBuffStat.WindWall, windWall);                                            Map<MapleBuffStat, Pair<Integer, Integer>> statups = new HashMap<>();                                            statups.put(MapleBuffStat.WindWall, new Pair<>(windWall, (int) chr.getBuffLimit(400031030)));                                            chr.getClient().getSession().writeAndFlush(BuffPacket.giveBuff(statups, chr.getBuffedEffect(MapleBuffStat.WindWall), chr));                                        } else {                                            chr.cancelEffectFromBuffStat(MapleBuffStat.WindWall);                                        }                                    } else if (chr.getBuffedEffect(MapleBuffStat.TrueSniping) == null && chr.getBuffedEffect(MapleBuffStat.Etherealform) == null && chr.getBuffedEffect(MapleBuffStat.IndieNotDamaged) == null && chr.getBuffedEffect(MapleBuffStat.NotDamaged) == null) {                                        int reduce = 0;                                        if (chr.getBuffedEffect(MapleBuffStat.IndieDamageReduce) != null) {                                            reduce = chr.getBuffedValue(MapleBuffStat.IndieDamageReduce);                                        } else if (chr.getBuffedEffect(MapleBuffStat.IndieBarrierDischarge) != null) {                                            reduce = -chr.getBuffedValue(MapleBuffStat.IndieBarrierDischarge);                                        }                                        if (type == 0 && chr.getTruePosition().y > -455 && chr.getTruePosition().y < 300) {                                            chr.addHP(-chr.getStat().getCurrentMaxHp() * (100 - reduce) / 100);                                        } else if (type == 1 && chr.getTruePosition().y > -2500 && chr.getTruePosition().y < -1800) {                                            chr.addHP(-chr.getStat().getCurrentMaxHp() * (100 - reduce) / 100);                                        }                                    }                                }                                MobTimer.getInstance().schedule(() -> {                                    if (monster.getHPPercent() <= 67 && monster.getWillHplist().contains(666)) {                                        MobSkillFactory.getMobSkill(242, 4).applyEffect(player, monster, skill, isFacingLeft);                                    } else if (monster.getHPPercent() <= 34 && monster.getWillHplist().contains(333)) {                                        MobSkillFactory.getMobSkill(242, 4).applyEffect(player, monster, skill, isFacingLeft);                                    } else if (monster.getHPPercent() <= 1 && monster.getWillHplist().contains(3)) {                                        MobSkillFactory.getMobSkill(242, 4).applyEffect(player, monster, skill, isFacingLeft);                                    }                                }, 1000);                            }, 3000);                            break;                        case 6: // 장풍 날리기                            break;                        case 7: // 2페이즈 : 거짓의 거울                            monster.getMap().broadcastMessage(CField.enforceMSG("거짓의 거울은 공격을 반전시켜요. 균열이 나타나면 공격을 마주하세요.", 245, 26000));                            monster.getMap().broadcastMessage(BossWill.willUseSpecial());//            			MobSkillFactory.getMobSkill(146, 14).applyEffect(player, monster, skill, isFacingLeft);                            MobSkillFactory.getMobSkill(242, 14).applyEffect(player, monster, skill, isFacingLeft);                            break;                        case 8: // 자체 바인드                            monster.getMap().broadcastMessage(BossWill.willStun());                            monster.getMap().broadcastMessage(CField.enforceMSG("지금이에요. 윌이 무방비 상태일 때 피해를 입혀야 해요.", 245, 12000));                            monster.setNextSkill(0);                            monster.setNextSkillLvl(0);                            if (monster.getId() == 8880300 || monster.getId() == 8880340) {                                MapleMonster will1 = monster.getMap().getMonsterById(monster.getId() + 3);                                if (will1 != null) {                                    monster.getMap().broadcastMessage(MobPacket.blockMoving(will1.getObjectId(), 3));                                }                                MapleMonster will2 = monster.getMap().getMonsterById(monster.getId() + 4);                                if (will2 != null) {                                    monster.getMap().broadcastMessage(MobPacket.blockMoving(will2.getObjectId(), 3));                                }                            } else {                                monster.getMap().broadcastMessage(MobPacket.blockMoving(monster.getObjectId(), 2));                            }                            MapTimer.getInstance().schedule(() -> {                                for (MapleMonster mob : monster.getMap().getAllMonstersThreadsafe()) {                                    mob.getMap().broadcastMessage(MobPacket.BlockAttack(mob, new ArrayList<>()));                                    mob.setSkillForbid(false);                                    mob.setUseSpecialSkill(false);                                }                            }, 10000);                            break;                        case 9: // 3페이즈 : 감염                            diseases.put(MapleBuffStat.WillPoison, new Pair<>(1, (int) duration));                            monster.getMap().spawnWillPoison(new WillPoison(player.getId()));                            break;                        case 10: // ?페이즈 : 다리 솟기 (유저 저격헝)                            player.getMap().broadcastMessage(BossWill.WillSpiderAttack(monster.getId(), skillId, skillLevel, 1, null));                            break;                        case 11: // ?페이즈 : 다리 솟기 (유저 비저격헝)                            player.getMap().broadcastMessage(BossWill.WillSpiderAttack(monster.getId(), skillId, skillLevel, 1, null));                            break;                        case 12: // 공통 : 눈동자 탄막                            id = 0;                            if (monster.getId() == 8880325 || monster.getId() == 8880326) {                                id = monster.getId() - 22;                            } else if (monster.getId() == 8880327 || monster.getId() == 8880328) {                                id = monster.getId() - 26;                            } else if (monster.getId() == 8880355 || monster.getId() == 8880356) {                                id = monster.getId() - 12;                            }                            if (Randomizer.nextBoolean()) {                                player.getMap().broadcastMessage(BossWill.createBulletEyes(0, id, -250, -370));                                player.getMap().broadcastMessage(BossWill.createBulletEyes(0, id, 250, -370));                            } else {                                player.getMap().broadcastMessage(BossWill.createBulletEyes(0, id, -470, -440));                                player.getMap().broadcastMessage(BossWill.createBulletEyes(0, id, 470, -440));                            }                            if (monster.getTruePosition().y < 0) {                                player.getMap().broadcastMessage(BossWill.createBulletEyes(1, id, 300, 100, -690, -2634, 695, -2019));                            } else {                                player.getMap().broadcastMessage(BossWill.createBulletEyes(1, id, 300, 100, -690, -455, 695, 160));                            }                            break;                        case 13: // 3페이즈 : 거미줄 설치                            //-800 ~ 800                            //-500 ~ 500                            int webSize = monster.getMap().getMapObjectsInRange(new Point(0, 0), Double.POSITIVE_INFINITY, Arrays.asList(MapleMapObjectType.WEB)).size();                            int randX = Math.max(1, 1600 - (webSize * 20));                            int randY = Math.max(1, 1000 - (webSize * 12));                            int x = Randomizer.nextInt(randX) - (randX / 2);                            int y = Randomizer.nextInt(randY) - (randY / 2);                            monster.getMap().spawnSpiderWeb(new SpiderWeb(Randomizer.nextInt(3), x, y));                            break;                        case 14: // 2페이즈 : 내려찍기 리버스                            if (monster.getId() != 8880301 && monster.getId() != 8880341) {//            				monster.getMap().broadcastMessage(BossWill.WillSpiderAttack(monster.getId() == 8880323 ? 8880301 : 8880341, skillId, skillLevel, Randomizer.rand(15, 20)));                                return;                            }                            monster.setSchedule(null);                            List<Integer> idz = new ArrayList<Integer>() {                                {                                    for (int i = 0; i < 9; i++) {                                        add(i);                                    }                                }                            };                            for (MapleMonster mob : monster.getMap().getAllMonstersThreadsafe()) {                                mob.getMap().broadcastMessage(MobPacket.BlockAttack(mob, idz));                                mob.setSkillForbid(true);                                mob.setUseSpecialSkill(true);                                if (mob.getId() == 8880306) {                                    monster.getMap().killMonster(mob);                                }                            }                            int startX = Randomizer.rand(-650, -480);                            List<Triple<Integer, Integer, Integer>> idt = new ArrayList<Triple<Integer, Integer, Integer>>() {                                {                                    for (int i = 1; i <= 3; i++) {                                        add(new Triple<>((i - 1) * 3, 1500 * i, startX + (160 * (i - 1))));                                        add(new Triple<>((i - 1) * 3 + 1, 1500 * i, startX + 400 + (160 * (i - 1))));                                        add(new Triple<>((i - 1) * 3 + 2, 1500 * i, startX + 800 + (160 * (i - 1))));                                    }                                }                            };                            for (int i = 1; i <= 5; ++i) {                                MobTimer.getInstance().schedule(() -> {                                    monster.getMap().broadcastMessage(BossWill.WillSpiderAttack(monster.getId(), skillId, skillLevel, Randomizer.rand(1, 2), idt));                                }, 6000 * i);                            }                            MobTimer.getInstance().schedule(() -> {                                if (monster.isUseSpecialSkill()) {                                    List<Integer> newHpList = new ArrayList<>();                                    if (monster.getHPPercent() <= 51 && monster.getWillHplist().contains(503)) {                                        newHpList.add(3);                                    } else if (monster.getHPPercent() <= 1 && monster.getWillHplist().contains(3)) {                                        //                                    } else {                                        newHpList.add(503);                                        newHpList.add(3);                                    }                                    monster.setWillHplist(newHpList);                                    monster.getMap().broadcastMessage(BossWill.setWillHp(monster.getWillHplist(), monster.getMap(), monster.getId(), monster.getId() + 3, monster.getId() + 4));                                    MobSkillFactory.getMobSkill(242, 8).applyEffect(player, monster, skill, isFacingLeft);                                } else {                                    for (MapleMonster mob : monster.getMap().getAllMonstersThreadsafe()) {                                        mob.getMap().broadcastMessage(MobPacket.BlockAttack(mob, new ArrayList<>()));                                        mob.setUseSpecialSkill(false);                                        mob.setSkillForbid(false);                                    }                                }                                if (monster.getSchedule() != null) {                                    monster.getSchedule().cancel(true);                                }                                monster.setSchedule(MobTimer.getInstance().schedule(() -> {                                    MobSkillFactory.getMobSkill(242, 7).applyEffect(player, monster, skill, isFacingLeft);                                }, 2 * 60 * 1000));                            }, 36000);                            break;                        case 15: // 1페이즈 : 혼란의 눈동자                            for (MapleCharacter chr : monster.getMap().getAllCharactersThreadsafe()) {                                monster.getMap().broadcastMessage(EffectPacket.showWillEffect(chr, 0, skillId, skillLevel));                            }                            MobTimer.getInstance().schedule(() -> {                                for (MapleCharacter chr : monster.getMap().getAllCharactersThreadsafe()) {                                    chr.getClient().getSession().writeAndFlush(CField.portalTeleport(Randomizer.nextBoolean() ? "ptup" : "ptdown"));                                    chr.getClient().getSession().writeAndFlush(BossWill.WillSpiderAttack(monster.getId(), skillId, skillLevel, Randomizer.nextInt(2), null));                                }                            }, 3000);                            break;                    }                case 246: // 진 힐라 검은 손                    List<Triple<Point, Integer, List<Rectangle>>> datas = new ArrayList<>();                    for (int i = 0; i < 7; ++i) {                        List<Rectangle> rectz = new ArrayList<>();                        int[] randXs = {0, 280, -560, 560, -280, -840, 840};                        int t = Randomizer.nextInt(randXs.length);                        int randX = randXs[t];                        int delay = (t + 1) * 250;                        int[][][] rectXs = {{{-75, 50}, {13, -50}, {83, 72}, {83, 72}},                        {{-81, 90}, {-59, -20}, {-25, 13}, {123, 31}, {138, -54}},                        {{-78, 28}, {-13, -50}, {42, 81}, {75, -18}, {133, 4}},                        {{-75, 50}, {13, -60}, {83, 72}, {83, 72}},                        {{-81, 90}, {-59, -20}, {-25, 13}, {123, 31}, {138, -54}},                        {{-78, 28}, {-13, -50}, {42, 81}, {75, -18}, {133, 4}},                        {{-78, 28}, {-13, -50}, {42, 81}, {75, -18}, {133, 4}},};                        int[][] rectX = rectXs[t];                        for (int j = 0; j < rectX.length; ++j) {                            rectz.add(new Rectangle(rectX[j][0], -80, rectX[j][1], 640)); // - rectX[j][0]  3번쨰칸                        }                        datas.add(new Triple<>(new Point(randX, -260), delay, rectz));                    }                    monster.getMap().broadcastMessage(MobPacket.jinHillahBlackHand(monster.getObjectId(), skillId, skillLevel, datas));                    break;                case 247: // 힐라 영혼 회수                    monster.getMap().setSandGlassTime(System.currentTimeMillis() + interval);                    monster.getMap().broadcastMessage(CField.JinHillah(4, null));                    for (MapleCharacter chr : monster.getMap().getAllCharactersThreadsafe()) {                        for (int i = 0; i < chr.getDeathCounts().length; ++i) {                            if (chr.getDeathCounts()[i] == 0) { // red                                chr.getDeathCounts()[i] = 2; // gray                            }                        }                        chr.getClient().getSession().writeAndFlush(CField.JinHillah(3, chr));                        chr.getMap().broadcastMessage(CField.JinHillah(10, chr));                    }                    int sandCount = 0;                    for (MapleCharacter chr : monster.getMap().getAllCharactersThreadsafe()) {                        sandCount += chr.liveCounts();                    }                    monster.getMap().setCandles((int) Math.round(sandCount * 0.5));                    monster.getMap().broadcastMessage(CField.JinHillah(0, player));                    monster.getMap().setLightCandles(0);                    monster.getMap().broadcastMessage(CField.JinHillah(1, player));                    monster.getMap().broadcastMessage(CField.JinHillah(8, player));                    break;                case 248: // 진 힐라 검은기운                    MapleMist mist = new MapleMist(new Rectangle(Randomizer.rand(-400, 300), Randomizer.rand(-400, 100), 400, 400), monster, this, (int) 8000);                    if (mist != null) {                        monster.getMap().spawnMist(mist, false);                    }                    break;                case 249: // 검은마법사 디버프 1                    //스봉 120, 39                    switch (skillLevel) {                        case 1: // 창조의 디버프                            diseases.put(MapleBuffStat.CurseOfCreation, new Pair<>(4, 6000));                            break;                        case 2: // 파괴의 디버프                            diseases.put(MapleBuffStat.CurseOfDestruction, new Pair<>(10, 6000));                            break;                    }                    if ((player.hasDisease(MapleBuffStat.CurseOfCreation) && skillLevel == 2) || (player.hasDisease(MapleBuffStat.CurseOfDestruction) && skillLevel == 1)) {                        player.setDeathCount((byte) (player.getDeathCount() - 1));                        player.getClient().getSession().writeAndFlush(CField.getDeathCount(player.getDeathCount()));                        if (player.getDeathCount() > 0) {                            player.addHP(-player.getStat().getCurrentMaxHp() * 60 / 100);                            if (player.isAlive()) {                                MobSkillFactory.getMobSkill(120, 39).applyEffect(player, monster, skill, isFacingLeft);                            }                        } else {                            player.addHP(-player.getStat().getCurrentMaxHp());                        }                    }                    break;                case 252: {                    MapleMist DustMist = new MapleMist(new Rectangle(-300, -1022, 510, 875), monster, this, (int) 5000);                    DustMist.setPosition(new Point(-45, -157));                    if (DustMist != null) {                        monster.getMap().spawnMist(DustMist, true);                    }                    break;                }                case 260:                    /*switch (skillLevel){                        case 3:                            player.getMap().broadcastMessage(CField.enforceMSG("친위대장 듄켈 : 한번 받아 봐라! 별조차 갈라버리는 내 궁극의 검기를!",272,2000));                            break;                    }*/                    break;                case 263:                    monster.getMap().broadcastMessage(MobPacket.BossSeren.SerenSpawnOtherMist(monster.getObjectId(), isFacingLeft, monster.getPosition()));                    break;                case 264:                    monster.getMap().broadcastMessage(MobPacket.BossSeren.SerenMobLazer(monster, this.skillLevel, this.skillLevel == 1 ? 1800 : 1500));                    break;            }            if (stats.size() > 0 && monster != null) {                if (player != null && lt != null && rb != null && skill) {                    monster.applyMonsterBuff(player.getMap(), stats, this);                    for (MapleMapObject mons : getObjectsInRange(monster, MapleMapObjectType.MONSTER)) {                        if (mons.getObjectId() != monster.getObjectId()) {                            ((MapleMonster) mons).applyMonsterBuff(player.getMap(), stats, this);                        }                    }                } else {                    monster.applyMonsterBuff(monster.getMap(), stats, this);                }            }            if (diseases.size() > 0 && player != null) {                if (lt != null && rb != null && skill && monster != null) {                    for (MapleCharacter chr : getPlayersInRange(monster, player)) {                        chr.giveDebuff(diseases, this);                    }                } else {                    player.giveDebuff(diseases, this);                }            }            if (monster != null) {                monster.setMp(monster.getMp() - getMpCon());            }            if (getSkillForbid() > 0 && monster != null) {                 monster.setSkillForbid(true);                 MobTimer.getInstance().schedule(() -> {                    monster.setSkillForbid(false);                 }, getSkillForbid());             }        } catch (Exception e) {            e.printStackTrace();        }    }    public int getSkillId() {        return skillId;    }    public int getSkillLevel() {        return skillLevel;    }    public int getMpCon() {        return mpCon;    }    public List<Integer> getSummons() {        return Collections.unmodifiableList(toSummon);    }    /*    public short getEffectDelay() {     return effect_delay;     }*/    public int getSpawnEffect() {        return spawnEffect;    }    public int getHP() {        return hp;    }    public int getX() {        return x;    }    public int getY() {        return y;    }    public Point getLt() {        return lt;    }    public Point getRb() {        return rb;    }    public int getLimit() {        return limit;    }    public boolean makeChanceResult() {        return prop >= 1.0 || Math.random() < prop;    }    private Rectangle calculateBoundingBox(Point posFrom, boolean facingLeft) {        Point mylt, myrb;        if (facingLeft) {            mylt = new Point(lt.x + posFrom.x, lt.y + posFrom.y);            myrb = new Point(rb.x + posFrom.x, rb.y + posFrom.y);        } else {            myrb = new Point(lt.x * -1 + posFrom.x, rb.y + posFrom.y);            mylt = new Point(rb.x * -1 + posFrom.x, lt.y + posFrom.y);        }        return new Rectangle(mylt.x, mylt.y, myrb.x - mylt.x, myrb.y - mylt.y);    }    private List<MapleCharacter> getPlayersInRange(Point pos, boolean facingleft, MapleCharacter player) {        final Rectangle bounds = calculateBoundingBox(pos, facingleft);        List<MapleCharacter> players = new ArrayList<MapleCharacter>();        players.add(player);        return player.getMap().getPlayersInRectAndInList(bounds, players);    }    private List<MapleCharacter> getPlayersInRange(MapleMonster monster, MapleCharacter player) {        final Rectangle bounds = calculateBoundingBox(monster.getTruePosition(), monster.isFacingLeft());        List<MapleCharacter> players = new ArrayList<MapleCharacter>();        players.add(player);        return monster.getMap().getPlayersInRectAndInList(bounds, players);    }    private List<MapleMapObject> getObjectsInRange(MapleMonster monster, MapleMapObjectType objectType) {        final Rectangle bounds = calculateBoundingBox(monster.getTruePosition(), monster.isFacingLeft());        List<MapleMapObjectType> objectTypes = new ArrayList<MapleMapObjectType>();        objectTypes.add(objectType);        return monster.getMap().getMapObjectsInRect(bounds, objectTypes);    }    public boolean isOnlyFsm() {        return onlyFsm;    }    public void setOnlyFsm(boolean b) {        this.onlyFsm = b;    }    public int getAction() {        return action;    }    public void setAction(Integer valueOf) {        this.action = valueOf;    }    public long getInterval() {        return interval;    }    public void setInterval(long interval) {        this.interval = interval;    }    public void setSkillAfter(int i) {        this.skillAfter = i;    }    public int getSkillAfter() {        return skillAfter;    }    public void setMobSkillDelay(MapleCharacter chr, MapleMonster monster, int skillAfter, short option, boolean isFacingLeft) {        try {            List<Rectangle> skillRectInfo = new ArrayList<>();            switch (skillId) {                case 213: { // 더스크, 듄켈                    switch (skillLevel) {                        case 10: { // 빨려들어는 이펙트                            skillRectInfo.add(new Rectangle(-300, -1022, 510, 875));                            MobTimer.getInstance().schedule(() -> {                                MobSkill msi = MobSkillFactory.getMobSkill(252, 1);                                msi.applyEffect(chr, monster, true, true);                            }, 2220);                            break;                        }                        case 13: {                            int paramrandom = Randomizer.nextInt(100);                            skillRectInfo.add(new Rectangle(108, -771, 300, 805));                            if (paramrandom < 50) {                                skillRectInfo.add(new Rectangle(-792, -771, 300, 805));                            } else {                                skillRectInfo.add(new Rectangle(-192, -771, 300, 805));                            }                            skillRectInfo.add(new Rectangle(-492, -771, 300, 805));                            skillRectInfo.add(new Rectangle(408, -771, 300, 805));                            break;                        }                        case 14: { // 찍는거                            MapleMap map = monster.getMap();                            for (int count = 0; count < 5; ++count) {                                int x = Randomizer.nextInt(map.getRight() - map.getLeft()) + map.getLeft();                                skillRectInfo.add(new Rectangle(x, -757, 200, 610));                            }                            break;                        }                        case 15: { // 회오리                            MapleMap map = monster.getMap();                            for (int count = 0; count < 3; ++count) {                                int x = Randomizer.nextInt(map.getRight() - map.getLeft()) + map.getLeft();                                skillRectInfo.add(new Rectangle(x, -907, 360, 760));                            }                            Collections.shuffle(skillRectInfo);                            break;                        }                    }                    chr.getClient().getSession().writeAndFlush(MobPacket.MobSkillDelay(monster.getObjectId(), skillId, skillLevel, skillAfter, option, skillRectInfo));                    break;                }                case 215: { // 데미안 똥떨구기                    chr.getMap().broadcastMessage(MobPacket.MobSkillDelay(monster.getObjectId(), skillId, skillLevel, skillAfter, option, skillRectInfo));                    break;                }                case 217: {                    switch (skillLevel) {                        case 6:                        case 13:                        case 14: // 발판                        case 16:                            List<Environment> envs = new ArrayList<>();                            List<Environment> selectedEnvs = new ArrayList<>();                            Map<String, Point> envpos = new HashMap<>();                            List<Integer> useIds = new ArrayList<>();                            //swoo4부터 넣으면 됨                            int[] xz = {-504, -284, -63, 167, 392, -490, -270, -49, 181, 406};                            for (Environment env : chr.getMap().getNodez().getEnvironments()) {                                int getevnum = Integer.parseInt(env.getName().replace("swoo", ""));                                if (getevnum >= 4) {                                    envs.add(env);                                }                            }                            int size = Math.min(envs.size(), Randomizer.rand(1, 4));                            for (Environment env : envs) {                                envpos.put(env.getName(), new Point(env.getX(), env.getY()));                            }                            for (int i = 0; i < size; ++i) {                                int id = Randomizer.nextInt(envs.size());                                int idz = Randomizer.nextInt(xz.length);                                Environment env = envs.get(id);                                while (useIds.contains(idz)) {                                    idz = Randomizer.nextInt(xz.length);                                }                                useIds.add(idz);                                int x = xz[idz];                                env.setX(x);                                skillRectInfo.add(new Rectangle(x, -81, 180, 65));                                selectedEnvs.add(env);                                envs.remove(env);                                chr.dropMessageGM(-8, "name : " + env.getName());                            }                            //상단 공중에 발판 보이는 패킷                            chr.getMap().broadcastMessage(MobPacket.MobSkillDelay(monster.getObjectId(), skillId, skillLevel, skillAfter, option, skillRectInfo));                            //발판 아래로 떨구는 패킷                            MobTimer.getInstance().schedule(() -> {                                chr.getMap().spawnEnergySphere(monster.getObjectId(), skillLevel, new MapleEnergySphere(true, size, -500, 100000, 15, 800, 0));                            }, 2000);                            //발판 판정 생성 패킷                            MobTimer.getInstance().schedule(() -> {                                for (Environment env : selectedEnvs) {                                    env.setY(-16);                                    env.setShow(true);                                }                                chr.getMap().broadcastMessage(CField.getUpdateEnvironment(chr.getMap().getNodez().getEnvironments()));                            }, 2800);                            //발판 판정 없애는 패킷                            MobTimer.getInstance().schedule(() -> {                                for (Environment env : selectedEnvs) {                                    env.setX((int) envpos.get(env.getName()).getX());                                    env.setY((int) envpos.get(env.getName()).getY());                                    env.setShow(false);                                }                                chr.getMap().broadcastMessage(CField.getUpdateEnvironment(chr.getMap().getNodez().getEnvironments()));                            }, 12800);                            break;                        case 7:                        case 8:                        case 15: // 구체                        case 17:                        case 23:                            chr.getMap().broadcastMessage(MobPacket.MobSkillDelay(monster.getObjectId(), skillId, skillLevel, skillAfter, option, skillRectInfo));                            MobTimer.getInstance().schedule(() -> {                                chr.getMap().spawnEnergySphere(monster.getObjectId(), skillLevel, new MapleEnergySphere(monster.getTruePosition().x, 10, 20000, 0, true, true));                            }, 3000);                            break;                    }                    break;                }                case 226: { // 얘는 고정임.                    option = 0;                    skillRectInfo.add(new Rectangle(-592, -1016, rb.x - lt.x, rb.y - lt.y));                    skillRectInfo.add(new Rectangle(-79, -1016, rb.x - lt.x, rb.y - lt.y));                    skillRectInfo.add(new Rectangle(383, -1016, rb.x - lt.x, rb.y - lt.y));                    chr.getMap().broadcastMessage(MobPacket.MobSkillDelay(monster.getObjectId(), skillId, skillLevel, skillAfter, option, skillRectInfo));//                map.setTempAreas(monster.getId(), skillRectInfo);                    break;                }                case 230: {                    option = 0; //areaSequenceDelay                    //6 : areaSequenceRandomSplit                    for (int count = 0; count < 10; ++count) {                        int x = -659 + (180 * Randomizer.nextInt(6));                        skillRectInfo.add(new Rectangle(x, -316, 120, 300));                    }                    Collections.shuffle(skillRectInfo);//                map.setTempAreas(monster.getId(), skillRectInfo);                    chr.getMap().broadcastMessage(MobPacket.MobSkillDelay(monster.getObjectId(), skillId, skillLevel, skillAfter, option, skillRectInfo));                    break;                }                case 241: {                    switch (skillLevel) {                        case 1:                            Map<MonsterStatus, MonsterStatusEffect> stats = new EnumMap<MonsterStatus, MonsterStatusEffect>(MonsterStatus.class);                            stats.put(MonsterStatus.MS_PopulatusTimer, new MonsterStatusEffect(skillId, (int) duration, x));                            monster.applyMonsterBuff(chr.getMap(), stats, this);                            chr.getMap().broadcastMessage(MobPacket.MobSkillDelay(monster.getObjectId(), skillId, skillLevel, 720, option, skillRectInfo));                            break;                        case 2:                            chr.getMap().broadcastMessage(MobPacket.MobSkillDelay(monster.getObjectId(), skillId, skillLevel, 720, option, skillRectInfo));                            break;                    }                }                default:                    chr.getClient().getSession().writeAndFlush(MobPacket.MobSkillDelay(monster.getObjectId(), skillId, skillLevel, skillAfter, option, skillRectInfo));                    break;            }            chr.dropMessageGM(6, skillId + " / " + skillLevel + " 의 딜레이 패킷 보냄 : " + skillAfter);        } catch (Exception e) {            e.printStackTrace();        }    }    public long getDuration() {        return duration;    }    public void setDuration(long duration) {        this.duration = duration;    }    public boolean isOnlyOtherSkill() {        return onlyOtherSkill;    }    public void setOnlyOtherSkill(boolean onlyOtherSkill) {        this.onlyOtherSkill = onlyOtherSkill;    }    public int getOtherSkillID() {        return otherSkillID;    }    public void setOtherSkillID(int otherSkillID) {        this.otherSkillID = otherSkillID;    }    public int getOtherSkillLev() {        return otherSkillLev;    }    public void setOtherSkillLev(int otherSkillLev) {        this.otherSkillLev = otherSkillLev;    }    public long getSkillForbid() {        return skillForbid;    }    public void setSkillForbid(long skillForbid) {        this.skillForbid = skillForbid;    }    public int getAfterAttack() {        return afterAttack;    }    public void setAfterAttack(int afterAttack) {        this.afterAttack = afterAttack;    }    public int getAfterAttackCount() {        return afterAttackCount;    }    public void setAfterAttackCount(int afterAttackCount) {        this.afterAttackCount = afterAttackCount;    }    public int getAfterDead() {        return afterDead;    }    public void setAfterDead(int afterDead) {        this.afterDead = afterDead;    }    public boolean isMobGroup() {        return isMobGroup;    }    public void setMobGroup(boolean isMobGroup) {        this.isMobGroup = isMobGroup;    }}